\documentclass[10pt,letter]{article}

%------------------------------------------------------------------------------------------------------------------------%
\usepackage{blindtext}
%\usepackage[french]{babel} 			% parce qu'on travaille en fraçais
\usepackage[utf8]{inputenc}	% maudit MAC!
%\usepackage[cyr]{aeguill}				% règle un problème de guillemets
\usepackage{amssymb}				% pour les lettres grecques
\usepackage{amsmath}				% plein de bonus pour les maths
\usepackage{amsfonts}				% plein de fonts pour les maths
\usepackage{fullpage} 				% parce qu'on a pas de note en marge
\usepackage{geometry}				% permet de changer les marges
\usepackage[pdftex]{graphicx}		% permet de dimensioner des graphismes
%\usepackage{tocbibind}				% inclut la TOC et la BIBLI dans la table des matière
\usepackage[small,bf]{caption}		% change le format des captions
\usepackage{wrapfig}					% permet de mettre des petite figures en petit
\usepackage{multicol}					% plusieurs colonnes
\usepackage{fancyhdr}				% pour faire des beaux headers
\usepackage[pdftex,plainpages=false,colorlinks=true,linkcolor=blue, citecolor=blue, urlcolor=blue]{hyperref}
\usepackage{fancyvrb}
%\usepackage{titlesec}

% pretty tilde:
%\usepackage{times}
%\usepackage{textcomp}
%

\usepackage{listings}
\usepackage{xcolor}
\usepackage{color}
\usepackage[framemethod=tikz]{mdframed}


\definecolor{myletters}{rgb}{1.0,0.972,827}
\definecolor{mymauve}{rgb}{0.262,0.098,0.188}
\definecolor{mycomment}{rgb}{0.315,0.47,0.74}
\definecolor{myblue}{rgb}{0.098,0.188,0.262}
\definecolor{myred}{rgb}{1.0,0.3,0.1}

%\definecolor{myletters}{rgb}{0.0,0.0.3,0.0}
%\definecolor{mymauve}{rgb}{0.97,0.95,0.97}
%\definecolor{mycomment}{rgb}{0.315,0.47,0.74}
%\definecolor{myblue}{rgb}{1.0,1.0,1.0}
%\definecolor{myred}{rgb}{1.0,0.3,0.1}


\newcommand{\dollar}{\mbox{\textdollar}}
\newcommand{\vdollar}{\texttt{\$}}



\newmdenv[hidealllines=true,
  backgroundcolor=mymauve,
  leftmargin=10pt,
  rightmargin=40pt,  
  innerleftmargin=-20pt,
  innerrightmargin=-20pt,
  innertopmargin=10pt,
  innerbottommargin=0pt,
  roundcorner=5pt,
  nobreak=true]{bashInput}

\lstset{columns=fullflexible,basicstyle=\ttfamily}

\lstdefinestyle{FileInputStyle}{
  language=bash,
  basicstyle=\small\ttfamily\color{myletters},
  frame=none, 
  backgroundcolor=\color{myblue},
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth,
  commentstyle=\color{mycomment},
  columns=flexible,
  showstringspaces=false,
  moredelim=**[is][\color{myred}]{~@}{@~},
  mathescape = true
}

\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\small\ttfamily\color{myletters},
  frame=none, 
  backgroundcolor=\color{mymauve},
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth,
  commentstyle=\color{mycomment},
  columns=flexible,
  showstringspaces=false,
  moredelim=**[is][\color{myred}]{~@}{@~},
  mathescape = true
}

\lstdefinestyle{BashOutputStyle}{
  language=bash,
  basicstyle=\scriptsize\ttfamily\color{myletters},
  frame=none, 
  backgroundcolor=\color{mymauve},
  linewidth=0.9\linewidth,
  xleftmargin=0.1\linewidth,
  commentstyle=\color{myletters},
  columns=flexible,
  showstringspaces=false,
  moredelim=**[is][\color{myred}]{~@}{@~},
  moredelim=**[is][\color{mymauve}]{@@}{@@},
  mathescape = true
}

%----------------------------------------------------------------------%

\setlength{\oddsidemargin}{25mm}
\setlength{\evensidemargin}{25mm}
\setlength{\voffset}{-1in}
\setlength{\hoffset}{-1in}
\setlength{\textwidth}{166mm}
\setlength{\topmargin}{4mm}
\setlength{\headheight}{10mm}
\setlength{\headsep}{12mm}
\setlength{\topskip}{0mm}
\setlength{\textheight}{228mm}

\pagestyle{fancy}
\makeatletter
\newenvironment{tablehere}
  {\def\@captype{table}}
  {}
\newenvironment{figurehere}
  {\def\@captype{figure}}
  {}
\makeatother

%\titleformat{\section}{\normalsize\bfseries}{\thesection}{0.7 em}{}
%\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{0.1 em}{}



%\addto\captionsfrench{\def\figurename{Figure}}
%\addto\captionsfrench{\def\tablename{Tableau}}


%Substitution des symbols


\fancyhead[LO,LE]{Maxime Charlebois \& Simon Verret}
\fancyhead[RO,RE]{Using Mammouth}

\begin{document}

%------------------------------------------------------------------------------------------------------------------------%

\begin{centering}

\Large{\textbf{Using Mammouth}}\\
\normalsize{Maxime Charlebois \& Simon Verret}\\
\small{Sherbrooke\\ September 2017}

\end{centering}

%------------------------------------------------------------------------------------------------------------------------%


\begin{abstract}
This is intended to help someone who wants to connect to the supercomputer mammouth. 
It shows how to put jobs in the execution queue, how to follow the progression for those jobs
and how to compile and run simple programs.
\end{abstract}

\tableofcontents

\renewcommand{\baselinestretch}{1.00}
\setlength{\parskip}{0.8\baselineskip}
\setlength{\parindent}{0mm}

%------------------------------------------------------------------------------------------------------------------------%

\vspace{2mm}

\section{Linux command line}
Before reading this, one should be familiar with Linux terminal 
(Bash language, same as Mac terminal or Unix terminal). 
%Strictly speaking, Linux is an OS like every other: 
%it allows you to acces direcories, modify files and execute programs. 
%However, Linux can be intimidating because it usually requires the terminal to operate.
The reader is expected to know the basic commands before reading this document. 
Here is a list of the most important commands that one should know before reading this document:

\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
$\dollar$ ls                         # list the file in the current directory
$\dollar$ cd                         # change directory
$\dollar$ pwd                        # show the current directory
$\dollar$ mkdir                      # make a new directory
$\dollar$ cp                         # copy files or directories
$\dollar$ mv                         # move files or directories
$\dollar$ rm                         # remove (delete) files or directories
$\dollar$ sudo                       # do a command in superuser
$\dollar$ cat                        # show the content of a file
$\dollar$ man                        # show the manual of a command
$\dollar$ grep                       # find a text or pattern in one or multiple file
\end{lstlisting}
\end{bashInput}

In this document, we use ``\texttt{\$}'' sign to indicate the terminal prompt 
and the ``\texttt{\#}'' indicates a comment in the bash language.
%The name ``local'' is the name of the terminal that run on your (local) computer.
%A different name will be used when we will be logged on a remorte computer like mammouth.
If you need help to get familiar with Linux (Unix), I suggest the first 6 tutorials of this website: 
\url{http://www.ee.surrey.ac.uk/Teaching/Unix/index.html}.

Another essential element is to learn how to edit a text file with a terminal text editor 
like \texttt{nano}  (basic and simple) or \texttt{vi}  (complicated and powerful).
This will become important when you need to edit a file remotely (on another computer, like mammouth) from your terminal.
With the basic setup, these editors won't allow for mouse inputs.
You must rely on multiple keyboard shortcuts to edit your file correctly.
For the present tutorial, the reader only need to know how to open, edit and save a file.

Another important tip is the copy-paste in command-line, hence if \texttt{nano}  and \texttt{vi}. 
On a PC keyboard, the Ctrl-c and Ctrl-v probably won't work.
You must then use Ctrl-shift-c and Ctrl-shift-v if that is the case.
This is useful if, for example, you want to copy the text from this ``.pdf'' file to the terminal. 
On Mac, the shortcuts Cmd-c and Cmd-v should remain the same.


\subsection{Connect to Mammouth}
Once you are familiar with Linux, you can connect to mammouth, the super calculator at Sherbrooke University. 
Of course, you will need to get a username and a password with the help of your supervisor.
Let's suppose here that your supervisor is Andre-Marie Tremblay and that the username you got is \texttt{charleb1} .
Now go into a terminal and type:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@local@~$\dollar$ ssh -X charleb1@tremblay-ms.ccs.usherbrooke.ca
\end{lstlisting}   
\end{bashInput}

Then enter your password, and that's it, you are connected! 
The name \texttt{local}  is the name of the terminal that run on your (local) computer.
A different name will be used when we are logged on a remote computer like mammouth.
Notice that you are connected to the MS, standing for \emph{Mammouth Serie}. 
There is also MP (\emph{Mammouth Parallel}), a different cluster with more computing cores, 
to which you can connect by replacing \texttt{tremblay-ms}  by \texttt{tremblay-mp2}  in the command.

\subsection{Moving files}
Here are some commands that can be useful to move files between your computer and mammouth. 
You must run them on a local terminal and not on a terminal logged onto mammouth.
Indeed, you need to specify an internet address or a ip.
Since you most likely don't know the ip address of your computer, 
it is always better to use these command on a local terminal.

To copy from mammouth to your computer:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@local@~$\dollar$ scp -r charleb1@tremblay-ms.ccs.usherbrooke.ca:~/path/file ./file
\end{lstlisting}
\end{bashInput}
and from your computer to mammouth
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@local@~$\dollar$ scp -r ./file charleb1@tremblay-ms.ccs.usherbrooke.ca:$\mathtt{\sim}$/path/file
\end{lstlisting}
\end{bashInput}
the ``-r '' (recursively) is to copy folders (like with the \texttt{cp} command). 
Your password will be asked like for \texttt{ssh}.%, except if you make it automatic (next).





\section{Launch jobs on Mammouth}

Most of the information in this section were taken from:
\url{http://wiki.calculquebec.ca/w/Running_jobs#tab=tab8}.
Once you are logged into mammouth, you can already execute some commands and codes.
But, you are on the interactive node, shared with other users of the department
(you can check who with the command \texttt{who} and even write to them with the command \texttt{write} ).
Since the node is interactive, you can run your code, interact with it and debug, 
but it should not be used for more than that.
If you want to launch a code and wait for the result, you need to do a job submission.
A rule of thumb is: if code that runs for more than 20 minutes or requires more than half of the node's 
processors (cores), it should be launched with a job submission.

\subsection{Job submissions}

There are two ways to submit jobs on mammouth, here I present the basic way with the command \texttt{qsub}. 
There is also a fancier and more powerful way, with the \texttt{bqsubmit}  command (see section \ref{bqsubmit}). 
When submitting jobs, one first need to ask for the necessary amount of cores and memory. 
This is done with a system called \emph{Torque} (identified by acronym PBS) which manage the priority of your jobs, 
given a set of mysterious rules.
%Although you could learn everythin on internet, here are my personal basics. 
The idea is to write a file containing the commands to execute as a script, preceded by a PBS header. 
Let's name this file \texttt{sub.pbs}. 
Here, I want to execute \texttt{echo "hello world"}  using 2 cores on mammouth (somewhat overkill) 
and record the terminal output in a file name \texttt{ecran\char`_out}  (otherwise lost):

Submission file \texttt{sub.pbs}:

\begin{bashInput}[backgroundcolor=myblue]
\begin{lstlisting}[style=FileInputStyle]
#!/bin/bash
#PBS -N nameToTrackYourJob
#PBS -q qwork@ms
#PBS -l nodes=1:ppn=2,walltime=00:05:00
cd $\dollar$PBS_O_WORKDIR
echo "hello world" >> output.dat
\end{lstlisting}
\end{bashInput}

The first line is the usual bash script header. 
The second line, the first PBS line, determines the name of the job, 
because keeping good track of the jobs you submit is a really good habit to take. 
The second PBS line determine the queue in which you want to submit your job. 
Apart from \texttt{qwork@ms}  (allows max 120h), there is also \texttt{qtest@ms}  (max $\sim$10h)  and \texttt{qlong@ms}  (max 1000h). 
If you want to launch job on MP, the most common queue is \texttt{qwork@mp2}. 
It is important to stress that you must be logged on MS when you \texttt{qsub}  a ``pbs'' file with \texttt{qwork@ms}  and on MP when you \texttt{qsub}  a ``pbs'' file with \texttt{qwork@mp2}.
The third PBS line specifies the requirements of one job. 
For example, here we ask for 1 node, 2 cores (ppn for ``processor per node''), and an expected maximum time of 00:05 hours (5 minutes). 
The idea behind this is that our allowed total time per core is counted and determines our priorities in the queues. 
We don't want to use too much. 

The last part is the executed script. 
The command \texttt{cd \$PBS\char`_O\char`_WORKDIR}  set the ``current directory'' at the directory from where the submission was called (with the environment variable \texttt{\$PBS\char`_O\char`_WORKDIR}) when running the script. 
This is necessary if you want the output files your script to end there. 

Finally, one can submit this once and for all:

\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ qsub sub.pbs
\end{lstlisting}
\end{bashInput}
The job gets a number which will be displayed and then is waiting in the queue.


On MS, there are 8 cores per node and 16 Go of memory. 
A single node is always reserved to a single user. 
A good habit is therefore to fill a node completely as often as possible, 
so that you don't waste the unused core time. 
So, one should send 8 jobs with node=1 and ppn=1 at a time, or 4 with ppn=2, or any other combination that gives 8. 
For memory greedy programs, it can be advised to ask for more cores even if the program uses only one of them. 
That way you won't have memory conflicts. 
%For example, with \verb qcm  I like to send only two 12-sites computations by node.


\subsection{Follow your jobs}

Once the job is submitted, one can check its status with the \texttt{qstat} command. 
A plain \texttt{qstat}  will yield a list of all the users. 
To get your specific jobs, use (-u for users):
%\begin{bashInput}
%\begin{lstlisting}[style=BashInputStyle]
%~@ms$\dollar$@~ qstat -nu charleb1
%\end{lstlisting}
%\end{bashInput}
\begin{bashInput}
\obeyspaces
\begin{lstlisting}[style=BashOutputStyle]
~@ms$\dollar$@~ qstat -nu charleb1

ms.m: 
@@...........................................................................@@Req'd@@...@@Req'd@@.......@@Elap
Job ID@@...............@@Username@@....@@Queue@@....@@Jobname@@.....@@SessID@@..@@NDS@@...@@TSK@@...@@Memory@@...@@Time@@....@@S@@...@@Time
--------------------@@.@@-----------@@.@@--------@@.@@-----------@@.@@------@@.@@-----@@.@@------@@.@@------@@.@@---------@@.@@-@@.@@---------
177107.ms.m@@..........@@charleb1@@....@@qwork@@....@@nameToTrack@@...@@4059@@.....@@1@@......@@2@@....@@--@@...@@00:05:00@@.@@R@@..@@00:00:02
@@...@@cs302/0+cs302/1
\end{lstlisting}
\end{bashInput}



The status of the job will be marked as Q if it is waiting in the queue and as R if running. 
Once the job is running you can see on which node it is, given that you added the -n option, for ``node''. 
Here, \texttt{qstat}  shows that the nodes \texttt{cs302} is used, with processors \texttt{0}  and \texttt{1} .
While the code is running, you can visit this particular node with the command \texttt{ssh}. 
Once on the node, you can, for example, check the CPU usage and the memory allocated with the command \texttt{top}: 

\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ ssh cs302
~@cs302$\dollar$@~ top
\end{lstlisting}
\end{bashInput}


Finally, if something is wrong, use \texttt{qdel}  with the number of the job, to kill it:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ qdel 177107.ms.m
\end{lstlisting}
\end{bashInput}



\subsection{Submit a lot of calculations}
\label{bqsubmit}

MP and MS offer another tool to submit a lot of jobs at the same time: BqTools.
This offer the possibility to launch the same code with different parameters and correctly allocate every job
and create every corresponding directory. 
This is the ideal way to scan multiple parameters, but requires a little more efforts. 
For now, we recommend the reader to consult \url{http://wiki.calculquebec.ca/w/BqTools/en}



\subsection{Monitor the available nodes}
One very useful command to see how many nodes are busy on the cluster is: 
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ bqmon
\end{lstlisting}
\end{bashInput}
Which will show you each available queue and the number of requests made on that queue.

\section{Compile on mammouth}

When you develop a code, you cannot compile it on your personal computer and copy the binary file on mammouth.
It will most probably won't work, and if it works, it will most probably not be optimal.
You must then learn to compile your code directly on the version of mammouth you want to run your code (MS or MP).

\subsection{Your first code}

A very basic source code can be obtained at the adresse: \\ \url{www.physique.usherbrooke.ca/quantique-udes/afmconductivities.tar.gz}. You can move it on mammouth (with \texttt{scp}) and uncompress it with: 
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ tar -xzf afmconductivities.tar.gz
\end{lstlisting}
\end{bashInput}
%\begin{bashInput}
%\begin{lstlisting}[style=BashInputStyle]
%~@ms$\dollar$@~ hg clone https://bitbucket.org/quantique-udes/afmconductivities
%\end{lstlisting}
%\end{bashInput}
You can go then in the newly created directory \texttt{afmconductivities}  and view the information in the README file.
In this directory, the code should compile directly with the command:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ make
\end{lstlisting}
\end{bashInput}
This command will read the \texttt{makefile}  and generate locally a executable binary file \texttt{afmCond}.
To run this code, you can type the command:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ ./afmCond
\end{lstlisting}
\end{bashInput}
This will read the \texttt{model.dat} file present in the directory and compute various physical quantities
(check the README for more information about the physics). 
With the present \texttt{model.dat} file, this should run under one minute.

\subsection{The \protect\Verb+bin+  directory}

The memory space on mammouth is expensive.
It is a good practice to avoid to copy-pasting your executables in every directory you want to use them.
A good practice is to use the \texttt{bin} directory.

In your home directory (the one you access by doing the \texttt{cd}  alone, or \texttt{cd \~}), you should have a directory named \texttt{bin}.
If it is not there, create it with \texttt{mkdir bin}.
This is the directory where you want to move (\texttt{mv}) your binary files in order to have access to this 
command from anywhere on your computer.
Avoid using binary names that corresponds to already existing terminal command, otherwise it could make this 
command (or your program) unreachable.

The \texttt{bin}  directory is automatically added to the executable \texttt{PATH}  on mammouth due to the lines

\begin{bashInput}[backgroundcolor=myblue]
\begin{lstlisting}[style=FileInputStyle]
export PATH=$\dollar$PATH:$\dollar$HOME/bin
\end{lstlisting}
\end{bashInput}
in \texttt{\textasciitilde\textbackslash.bash\char`_profile}  file.
You can create your own \texttt{bin}  directory by adding a similar line in your \\ \texttt{\textasciitilde\textbackslash.bash\char`_profile} file 
or \texttt{\textasciitilde\textbackslash.bashrc}  file.

\subsection{The \texttt{module}  command}

In order to avoid that every user install the same library multiple times, 
some program on mammouth compiled and shared for all users.
These are called ``modules'' and can be managed with the \texttt{module} command.

Let's download another source code that requires some modules at the adresse:
\url{www.physique.usherbrooke.ca/quantique-udes/onebody.tar.gz} and ``untar'' it using the same procedure.
%\begin{bashInput}
%\begin{lstlisting}[style=BashInputStyle]
%~@ms$\dollar$@~ hg clone https://bitbucket.org/quantique-udes/onebody
%\end{lstlisting}
%\end{bashInput}
If you go into the directory of \texttt{onebody} and type \texttt{make}, you will most likely receive an error message.
This is because this code requires a more recent \texttt{gcc} compiler and some external libraries 
(Cuba and Lapack).
On MS, the libraries you need to load are obtained with the command:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ module add gcc/6.4.0 cuba/4.0 intel64/12.1.3.293
\end{lstlisting}
\end{bashInput}
and on MP the libraries are:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@mp2$\dollar$@~ module add gcc/6.1.0 cuba/4.0 intel64/13.1.3.192
\end{lstlisting}
\end{bashInput}
With these modules loaded, you can compile (\texttt{make}) and run (\texttt{oneBody\char`_ms} or \texttt{oneBody\char`_mp}) 
the code.

Here are some more commands you can use to play with the modules:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ module list                     # list the modules loaded
~@ms$\dollar$@~ module avail                    # modules available on the current computer
~@ms$\dollar$@~ module add mymodules            # you already know
~@ms$\dollar$@~ module rm mymodules             # remove a loaded module
~@ms$\dollar$@~ module initadd mymodules        # add module to the default modules list
~@ms$\dollar$@~ module initrm mymodules         # rm module to the default modules list
\end{lstlisting}
\end{bashInput}

The last two lines are very important. 
Indeed, most of the time, you need modules not only for the compilation, 
but also for the execution of the binary.
If you try to logout from mammouth and come back, the code you compiled won't run anymore
unless you used \texttt{initadd} with the correct modules. 
These commands edit the file \texttt{\textasciitilde\textbackslash.modules}  (or \texttt{\textasciitilde\textbackslash.modules\char`_mp2} on MP).
You can edit these files manually, but there is a good risk that these two commands won't work anymore.
If that is the case, you can always delete them, and the system will create fresh new \texttt{.modules}  files.

\subsection{Plotting some results using \texttt{gnuplot}}

It can be useful to rapidly plot some results obtained.
As long as the result are in text format, it should be possible to plot using \texttt{gnuplot}.
Both codes downloaded in this tutorial provide some plotting example in their README

To get a pretty Fermi surface, you can go to the directory \texttt{onebody}  and run these commands:
\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ ./oneBody_ms mdc
~@ms$\dollar$@~ module add gnuplot/4.5
~@ms$\dollar$@~ gnuplot
~@gnuplot>@~ plot 'mdc.dat' matrix with image
~@gnuplot>@~ q
\end{lstlisting}
\end{bashInput}
The last line is to exit gnuplot. You can also plot a more traditional plot (x-y axis) with:

\begin{bashInput}
\begin{lstlisting}[style=BashInputStyle]
~@ms$\dollar$@~ ./oneBody_ms l
~@ms$\dollar$@~ gnuplot
~@gnuplot>@~ plot 'n.out' u 1:2 w lp
\end{lstlisting}
\end{bashInput}

\texttt{gnuplot} is much more powerful and configurable. But this gives a good starting point to visualize your 
data on mammouth.


\end{document}




